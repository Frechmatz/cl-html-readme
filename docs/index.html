<html><body><header><h1>cl-html-readme</h1>A Documentation Generator for Common Lisp projects. The key concepts are as follows:
<ul>
    <li>The generated documentation consists of HTML files.</li>
    <li>Docstrings are using HTML as markup language.</li>
    <li>Adding verbatim HTML to the documentation via plain strings or HTML files.</li>
    <li>Easy adding of source code files to the documentation.</li>
    <li>Generation of HTML headings, a Table Of Contents and HTML semantic elements via a DSL.</li>
    <li>No wrapping of the <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm">documentation</a> function.</li>
    <li>Keeping predefined HTML markup at a minimum.</li>
</ul><p>The source code is available <a href="https://github.com/Frechmatz/cl-html-readme">here</a>.</p></header><nav><h1>Table of contents</h1><ul><li><a href="#Installation">Installation</a></li><li><a href="#DSL">DSL</a><ul><li><a href="#Example: Heading elements and Table of Contents">Example: Heading elements and Table of Contents</a></li><li><a href="#Example: Semantic elements">Example: Semantic elements</a></li><li><a href="#Example: HTML Classes and Styles">Example: HTML Classes and Styles</a></li></ul></li><li><a href="#API">API</a></li><li><a href="#Example: Readme Generation">Example: Readme Generation</a></li></ul></nav><section><h1 id="Installation">Installation</h1><pre><code>
cd ~/quicklisp/local-projects
git clone https://github.com/Frechmatz/cl-html-readme.git
</code></pre><h1 id="DSL">DSL</h1><p>The DSL (Domain Specific Language) of cl-html-readme shall make it easy
to define an automatically generated HTML skeleton consisting of semantic elements, heading elements and
a table of contents. Beside these predefined elements the actual "content" consists of plain strings.
This library does not know anything about documentation strings and does not try in any way
to wrap the <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm">documentation</a> function of Common Lisp.
</p><p>The following examples shall demonstrate the concept.</p><h2 id="Example: Heading elements and Table of Contents">Example: Heading elements and Table of Contents</h2><h3>DSL</h3><p><pre><code>((heading (:name "Example"))
 (heading (:name "Table of contents")
          (toc))
 (heading (:name "Chapter 1" :toc t)) "Lorem ipsum"
 (heading (:name "Chapter 2" :toc t)) "Lorem ipsum")))</code></pre></p><h3>Generated HTML</h3><p><pre><code>&lt;h1&gt;Example
&lt;/h1&gt;
&lt;h1&gt;Table of contents
&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href="#Chapter 1"&gt;Chapter 1
    &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href="#Chapter 2"&gt;Chapter 2
    &lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="Chapter 1"&gt;Chapter 1
&lt;/h1&gt;Lorem ipsum
&lt;h1 id="Chapter 2"&gt;Chapter 2
&lt;/h1&gt;Lorem ipsum</code></pre></p><h2 id="Example: Semantic elements">Example: Semantic elements</h2><h3>DSL</h3><p><pre><code>((semantic (:name "header")
           (heading (:name "Example")))
 (semantic (:name "nav")
           (heading (:name "Table of contents")
                    (toc)))
 (semantic (:name "section")
           (heading (:name "Chapter 1" :toc t))
           "Lorem ipsum"
           (heading (:name "Chapter 2" :toc t))
           "Lorem ipsum")
 (semantic (:name "footer") "Lorem ipsum"))</code></pre></p><h3>Generated HTML</h3><p><pre><code>&lt;header&gt;
  &lt;h1&gt;Example
  &lt;/h1&gt;
&lt;/header&gt;
&lt;nav&gt;
  &lt;h1&gt;Table of contents
  &lt;/h1&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;a href="#Chapter 1"&gt;Chapter 1
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href="#Chapter 2"&gt;Chapter 2
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;section&gt;
  &lt;h1 id="Chapter 1"&gt;Chapter 1
  &lt;/h1&gt;Lorem ipsum
  &lt;h1 id="Chapter 2"&gt;Chapter 2
  &lt;/h1&gt;Lorem ipsum
&lt;/section&gt;
&lt;footer&gt;Lorem ipsum
&lt;/footer&gt;</code></pre></p><h2 id="Example: HTML Classes and Styles">Example: HTML Classes and Styles</h2><h3>DSL</h3><p><pre><code>((semantic (:name "header" :class "semantic-class" :style "semantic-style" )
           (heading (:name "Example" :class "heading-class" :style "heading-style")))
 (semantic (:name "nav")
           (heading (:name "Table of contents")
                    (toc (:root-class "toc-root-class"
                          :root-style "toc-root-style"
                          :container-class "toc-container-class"
                          :container-style "toc-container-style"
                          :item-class "toc-item-class"
                          :item-style "toc-item-style"))))
 (semantic (:name "section")
           (heading (:name "Chapter 1" :toc t)
                    "Lorem ipsum"
                    (heading (:name "Chapter 1.1" :toc t)
                             "Lorem ipsum"))
           (heading (:name "Chapter 2" :toc t))
           "Lorem ipsum")
 (semantic (:name "footer") "Lorem ipsum"))</code></pre></p><h3>Generated HTML</h3><p><pre><code>&lt;header class="semantic-class" style="semantic-style"&gt;
  &lt;h1 class="heading-class" style="heading-style"&gt;Example
  &lt;/h1&gt;
&lt;/header&gt;
&lt;nav&gt;
  &lt;h1&gt;Table of contents
  &lt;/h1&gt;
  &lt;ul class="toc-root-class" style="toc-root-style"&gt;
    &lt;li class="toc-item-class" style="toc-item-style"&gt;
      &lt;a href="#Chapter 1"&gt;Chapter 1
      &lt;/a&gt;
      &lt;ul class="toc-container-class" style="toc-container-style"&gt;
        &lt;li class="toc-item-class" style="toc-item-style"&gt;
          &lt;a href="#Chapter 1.1"&gt;Chapter 1.1
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li class="toc-item-class" style="toc-item-style"&gt;
      &lt;a href="#Chapter 2"&gt;Chapter 2
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;section&gt;
  &lt;h1 id="Chapter 1"&gt;Chapter 1
  &lt;/h1&gt;Lorem ipsum
  &lt;h2 id="Chapter 1.1"&gt;Chapter 1.1
  &lt;/h2&gt;Lorem ipsum
  &lt;h1 id="Chapter 2"&gt;Chapter 2
  &lt;/h1&gt;Lorem ipsum
&lt;/section&gt;
&lt;footer&gt;Lorem ipsum
&lt;/footer&gt;</code></pre></p><h1 id="API">API</h1><b>doc-to-html</b>&nbsp;(output-stream documentation)<p>Serializes a documentation object to HTML. The function has the following parameters:
   <ul>
       <li>output-stream A stream into which the resulting HTML is written.</li>
       <li>documentation A list following the syntax of the DSL.</li>
   </ul></p><b>*home-directory*</b><p>Home directory of the project for which documentation is to be generated.</p><b>*tab-width*</b><p>Width of a tab. Used, when tabs are to be replaced with space characters.</p><b>make-path</b>&nbsp;(path)<p>Creates a path relative to *home-directory*. The function has the following arguments:
   <ul>
      <li>path The path, e.g. examples/example-1.lisp.</li>
   </ul></p><b>read-file</b>&nbsp;(path &key (replace-tabs nil) (escape nil))<p>Reads a text file and returns it as a string. The function has the following arguments:
   <ul>
      <li>path Path of the file relative to *home-directory*.</li>
      <li>:replace-tabs If t then tabs are replaced with spaces according to the *tab-width* variable.</li>
      <li>:escape If t then special characters are replaced with HTML character entities.</li>
   </ul></p><h1 id="Example: Readme Generation">Example: Readme Generation</h1><p>This library has not been created for the fun of it, but to gain full control of documentation generation 
in a easy way. Be it styling via CSS, embedded JavaScript, inclusion of source code files or markup used by documentation strings.</p>
<p>The following example shows how the documentation of cl-html-readme is generated. 
It uses the <a href="https://github.com/eudoxia0/docparser">docparser</a> library to retrieve metadata such as documentation strings.</p><p><pre><code>(in-package :cl-html-readme-make-readme)

;;
;; Helper functions for HTML formatting and accessing metadata
;;

(defun get-node (index package-name symbol-name)
  (aref (docparser:query
         index
         :package-name (string-upcase package-name)
         :symbol-name (string-upcase symbol-name))
        0))
  
(defun make-function-string (index package-name symbol-name)
  (let* ((node (get-node index package-name symbol-name))
         (lambda-list (docparser:operator-lambda-list node)))
    (concatenate
     'string
     "&lt;b&gt;" (string-downcase symbol-name) "&lt;/b&gt;&amp;nbsp;"
     (string-downcase (format nil "~a" (if lambda-list lambda-list "()")))
     "&lt;p&gt;" (docparser:node-docstring node) "&lt;/p&gt;")))

(defun make-variable-string (index package-name symbol-name)
  (let ((node (get-node index package-name symbol-name)))
    (concatenate
     'string
     "&lt;b&gt;" (string-downcase symbol-name) "&lt;/b&gt;"
     "&lt;p&gt;" (docparser:node-docstring node) "&lt;/p&gt;")))
  
(defun make-code-string (path)
  (concatenate
   'string
   "&lt;p&gt;&lt;pre&gt;&lt;code&gt;"
   (cl-html-readme:read-file path :replace-tabs t :escape t)
   "&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;"))

(defun now ()
  "Returns a string representing the current date and time."
  (multiple-value-bind (sec min hr day mon yr dow dst-p tz)
      (get-decoded-time)
    (declare (ignore dow dst-p tz))
    ;; 2018-09-19 21:28:16
    (let ((str (format nil "~4,'0d-~2,'0d-~2,'0d  ~2,'0d:~2,'0d:~2,'0d" yr mon day hr min sec)))
      str)))

;;
;; Readme
;;

(defun get-readme (index)
    `("&lt;html&gt;&lt;body&gt;"
      (semantic (:name "header")
                (heading (:name "cl-html-readme"))
                ,(cl-html-readme:read-file "make-readme/introduction.html")
                "&lt;p&gt;The source code is available &lt;a href=\"https://github.com/Frechmatz/cl-html-readme\"&gt;here&lt;/a&gt;.&lt;/p&gt;")
      (semantic (:name "nav")
                (heading (:name "Table of contents")
                         (toc)))
      (semantic (:name "section")
                (heading (:name "Installation" :toc t)
                         ,(cl-html-readme:read-file "make-readme/installation.html"))
                (heading (:name "DSL" :toc t)
                         "&lt;p&gt;The DSL (Domain Specific Language) of cl-html-readme shall make it easy
to define an automatically generated HTML skeleton consisting of semantic elements, heading elements and
a table of contents. Beside these predefined elements the actual \"content\" consists of plain strings.
This library does not know anything about documentation strings and does not try in any way
to wrap the &lt;a href=\"http://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm\"&gt;documentation&lt;/a&gt; function of Common Lisp.
&lt;/p&gt;&lt;p&gt;The following examples shall demonstrate the concept.&lt;/p&gt;"
                         (heading (:name "Example: Heading elements and Table of Contents" :toc t)
                                  (heading (:name "DSL")
                                           ,(make-code-string "make-readme/dsl-example-plain.dsl"))
                                  (heading (:name "Generated HTML")
                                           ,(make-code-string "make-readme/dsl-example-plain.html")))
                         (heading (:name "Example: Semantic elements" :toc t)
                                  (heading (:name "DSL")
                                           ,(make-code-string "make-readme/dsl-example-semantic.dsl"))
                                  (heading (:name "Generated HTML")
                                           ,(make-code-string "make-readme/dsl-example-semantic.html")))
                         (heading (:name "Example: HTML Classes and Styles" :toc t)
                                  (heading (:name "DSL")
                                           ,(make-code-string "make-readme/dsl-example-styling.dsl"))
                                  (heading (:name "Generated HTML")
                                           ,(make-code-string "make-readme/dsl-example-styling.html"))))
                (heading (:name "API":toc t)
                         ,(make-function-string index "cl-html-readme" "doc-to-html")
                         ,(make-variable-string index "cl-html-readme" "*home-directory*")
                         ,(make-variable-string index "cl-html-readme" "*tab-width*")
                         ,(make-function-string index "cl-html-readme" "make-path")
                         ,(make-function-string index "cl-html-readme" "read-file"))
                (heading (:name "Example: Readme Generation" :toc t)
                         "&lt;p&gt;This library has not been created for the fun of it, but to gain full control of documentation generation 
in a easy way. Be it styling via CSS, embedded JavaScript, inclusion of source code files or markup used by documentation strings.&lt;/p&gt;
&lt;p&gt;The following example shows how the documentation of cl-html-readme is generated. 
It uses the &lt;a href=\"https://github.com/eudoxia0/docparser\"&gt;docparser&lt;/a&gt; library to retrieve metadata such as documentation strings.&lt;/p&gt;"
                         ,(make-code-string "make-readme/make-readme.lisp")))
      (semantic (:name "footer")
                "&lt;hr/&gt;&lt;p&gt;&lt;small&gt;Generated " ,(now) "&lt;/small&gt;&lt;/p&gt;")
      "&lt;/body&gt;&lt;/html&gt;"))

;;
;; Generate readme
;;

(defun make-readme ()
  (let ((index (docparser:parse :cl-html-readme)))
    (let ((cl-html-readme:*home-directory* (asdf:system-source-directory :cl-html-readme-make-readme)))
      (with-open-file (fh (cl-html-readme:make-path "docs/index.html")
                          :direction :output
                          :if-exists :supersede
                          :if-does-not-exist :create
                          :external-format :utf-8)
        (cl-html-readme:doc-to-html fh (get-readme index)))))
    "DONE")

;;(make-readme)</code></pre></p></section><footer><hr/><p><small>Generated 2020-11-13  23:21:24</small></p></footer></body></html>